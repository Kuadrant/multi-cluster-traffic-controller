# shellcheck shell=bash

ocmInitHub() {
    hubCluster=$1

    ${CLUSTERADM_BIN} --context=kind-${hubCluster} init --wait
    kubectl --context=kind-${hubCluster} -n open-cluster-management-hub wait --timeout=300s --for=condition=Available deployments --all

    # Deploy some resources to let argocd use Placements
    cat <<EOF | kubectl apply --context kind-${hubCluster} -f -
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ocm-placement-generator
  namespace: argocd
data:
  apiVersion: cluster.open-cluster-management.io/v1beta1
  kind: placementdecisions
  statusListKey: decisions
  matchKey: clusterName

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ocm-placement-consumer
  namespace: argocd
rules:
  - apiGroups: ["cluster.open-cluster-management.io"]
    resources: ["placementdecisions"]
    verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ocm-placement-consumer:argocd
  namespace: argocd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ocm-placement-consumer
subjects:
  - kind: ServiceAccount
    namespace: argocd
    name: mctc-argocd-applicationset-controller

EOF

    # Bind the argocd namespace in the hub cluster to the global clusterset
    ${CLUSTERADM_BIN} --context=kind-${hubCluster} clusterset bind global --namespace argocd
}

ocmAddCluster() {
    hubCluster=$1
    managedCluster=$2

    HUB_API_SERVER=$(kubectl config view -o jsonpath="{$.clusters[?(@.name == 'kind-${hubCluster}')].cluster.server}")
    OCM_BOOTSTRAP_TOKEN=$(${CLUSTERADM_BIN} get token --context kind-${hubCluster} | awk 'BEGIN{FS="="}/token/{print $2}')

    ${CLUSTERADM_BIN} join --hub-token ${OCM_BOOTSTRAP_TOKEN} --hub-apiserver ${HUB_API_SERVER} \
        --cluster-name ${managedCluster} --force-internal-endpoint-lookup --context kind-${managedCluster} --wait
    ${CLUSTERADM_BIN} accept --clusters ${managedCluster} --context kind-${hubCluster} --wait

}